{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red89\green138\blue67;\red202\green202\blue202;\red70\green137\blue204;
\red67\green192\blue160;\red212\green214\blue154;\red167\green197\blue152;\red194\green126\blue101;}
{\*\expandedcolortbl;;\cssrgb\c41569\c60000\c33333;\cssrgb\c83137\c83137\c83137;\cssrgb\c33725\c61176\c83922;
\cssrgb\c30588\c78824\c69020;\cssrgb\c86275\c86275\c66667;\cssrgb\c70980\c80784\c65882;\cssrgb\c80784\c56863\c47059;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 https://leetcode.com/problems/word-break/\
\
Brute force would be :\
s= leetcode and dictionary:leet, code\
See what we do here is that we need to start from l check any dictionary exist or not and the le lee leet see matching then the that substring to 0 and start from next string like c and continue to code and if substring exist at end then we know dictionary is false \
\
Or \
We can check from the each dictionary word exist or not from he above\
\
\
Optimised solution :\
https://www.youtube.com/watch?v=J5WBzlHSwR0&t=1s\
See this code here:\
\
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 /* Approach : Recursion + Memo\
\pard\pardeftab720\partightenfactor0
\cf3 \strokec3 Try all possible splits and memoize to reduce time complexity\
Time : O(n ^ 2)\
Space : O(n)       // map + dp + recursion stack\
\pard\pardeftab720\partightenfactor0
\cf2 \strokec2 */\cf3 \strokec3 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \strokec4 class\cf3 \strokec3  \cf5 \strokec5 Solution\cf3 \strokec3  \{\
\cf4 \strokec4 public\cf3 \strokec3 :\
\cf4 \strokec4 int\cf3 \strokec3  \cf6 \strokec6 f\cf3 \strokec3 (\cf4 \strokec4 int\cf3 \strokec3  index, string& s, unordered_map<string, \cf4 \strokec4 bool\cf3 \strokec3 >& dict, vector<\cf4 \strokec4 int\cf3 \strokec3 >& dp) \{\
        \cf2 \strokec2 // base condition\cf3 \strokec3 \
        \cf4 \strokec4 if\cf3 \strokec3  (index >= s.\cf6 \strokec6 size\cf3 \strokec3 ()) \cf4 \strokec4 return\cf3 \strokec3  \cf7 \strokec7 1\cf3 \strokec3 ;\
\
        \cf2 \strokec2 // already computed\cf3 \strokec3 \
        \cf4 \strokec4 if\cf3 \strokec3  (dp[index] != -\cf7 \strokec7 1\cf3 \strokec3 ) \cf4 \strokec4 return\cf3 \strokec3  dp[index]; \
        \
        \cf2 \strokec2 // Try all cuts\cf3 \strokec3 \
        string curr = \cf8 \strokec8 ""\cf3 \strokec3 ;\
        \cf4 \strokec4 for\cf3 \strokec3  (\cf4 \strokec4 int\cf3 \strokec3  i = index; i < s.\cf6 \strokec6 size\cf3 \strokec3 (); i++) \{\
            curr.\cf6 \strokec6 push_back\cf3 \strokec3 (s[i]);\
            \cf2 \strokec2 // if curr string present in dict, check for remaining part\cf3 \strokec3 \
            \cf4 \strokec4 if\cf3 \strokec3 (dict[curr] && \cf6 \strokec6 f\cf3 \strokec3 (i+\cf7 \strokec7 1\cf3 \strokec3 , s, dict, dp))\
                \cf4 \strokec4 return\cf3 \strokec3  dp[index] = \cf7 \strokec7 1\cf3 \strokec3 ;\
        \}\
        \cf2 \strokec2 // split not possible\cf3 \strokec3 \
        \cf4 \strokec4 return\cf3 \strokec3  dp[index] = \cf7 \strokec7 0\cf3 \strokec3 ;\
    \}\
\
    \cf4 \strokec4 bool\cf3 \strokec3  \cf6 \strokec6 wordBreak\cf3 \strokec3 (string s, vector<string>& wordDict) \{\
        \cf2 \strokec2 // store dictionary words in map\cf3 \strokec3 \
        unordered_map<string, \cf4 \strokec4 bool\cf3 \strokec3 > dict;\
        \cf4 \strokec4 for\cf3 \strokec3  (\cf4 \strokec4 auto\cf3 \strokec3 & word : wordDict) \
            dict[word] = \cf4 \strokec4 true\cf3 \strokec3 ;\
\
        vector<\cf4 \strokec4 int\cf3 \strokec3 > \cf6 \strokec6 dp\cf3 \strokec3 (s.\cf6 \strokec6 size\cf3 \strokec3 (),-\cf7 \strokec7 1\cf3 \strokec3 );    \cf2 \strokec2 // memo\cf3 \strokec3 \
        \cf2 \strokec2 // Write recursion function to check all cuts\cf3 \strokec3 \
        \cf2 \strokec2 // index, string, map , dp\cf3 \strokec3 \
        \cf4 \strokec4 return\cf3 \strokec3  \cf6 \strokec6 f\cf3 \strokec3 (\cf7 \strokec7 0\cf3 \strokec3 , s, dict, dp);\
    \}\
\};\
\
\
TC:O(n^2) as we need to n index need to go for each loop n times\
SC:O(n) as here dp taken for that omly}