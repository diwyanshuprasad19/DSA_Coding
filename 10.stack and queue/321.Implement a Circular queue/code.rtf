{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\froman\fcharset0 Times-Bold;
\f3\froman\fcharset0 Times-Roman;\f4\fmodern\fcharset0 Courier;\f5\fnil\fcharset0 STIXTwoMath-Regular;
}
{\colortbl;\red255\green255\blue255;\red183\green111\blue179;\red30\green30\blue30;\red70\green137\blue204;
\red194\green126\blue101;\red202\green202\blue202;\red67\green192\blue160;\red212\green214\blue154;\red140\green211\blue254;
\red167\green197\blue152;\red89\green138\blue67;\red202\green202\blue202;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c77255\c52549\c75294;\cssrgb\c15686\c15686\c15686;\cssrgb\c33725\c61176\c83922;
\cssrgb\c80784\c56863\c47059;\cssrgb\c83137\c83137\c83137;\cssrgb\c30588\c78824\c69020;\cssrgb\c86275\c86275\c66667;\cssrgb\c61176\c86275\c99608;
\cssrgb\c70980\c80784\c65882;\cssrgb\c41569\c60000\c33333;\cssrgb\c83137\c83137\c83137;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 https://leetcode.com/problems/design-circular-queue/submissions/1480329555/\
\
\
// C++ program for insertion and\
// deletion in Circular Queue\
#include <bits/stdc++.h>\
using namespace std;\
\
class Node \{\
  public:\
    int data;\
    Node *next;\
    Node(int newdata) \{\
        data = newdata;\
        next = nullptr;\
    \}\
\};\
\
class Queue \{\
  public:\
    Node *front, *rear;\
    Queue() \{\
        front = rear = nullptr;\
    \}\
\};\
\
// Function to insert element in a Circular queue\
void enQueue(Queue *q, int value) \{\
    struct Node *newNode = new Node(value);\
\
    if (q->front == nullptr)\
        q->front = newNode;\
    else\
        q->rear->next = newNode;\
\
    q->rear = newNode;\
    q->rear->next = q->front;\
\}\
\
// Function to delete element from Circular Queue\
int deQueue(Queue *q) \{\
\
    // if queue is empty\
    if (q->front == nullptr) \{\
        return -1;\
    \}\
\
    int value;\
\
    // If this is the last node to be deleted\
    if (q->front == q->rear) \{\
        value = q->front->data;\
        delete (q->front);\
        q->front = nullptr;\
        q->rear = nullptr;\
    \}\
    else \{\
        Node *temp = q->front;\
        value = temp->data;\
        q->front = q->front->next;\
        q->rear->next = q->front;\
        delete (temp);\
    \}\
\
    return value;\
\}\
\
// Function to return the front value\
int front(Queue *q) \{\
    Node *front = q->front;\
\
    if (front == nullptr) \{\
        return -1;\
    \}\
\
    return front->data;\
\}\
\
// Function to return the rear value\
int rear(Queue *q) \{\
    Node *rear = q->rear;\
\
    if (rear == nullptr) \{\
        return -1;\
    \}\
\
    return rear->data;\
\}\
\
void printQueue(Queue *q) \{\
    Node *curr = q->front;\
\
    do \{\
        cout << curr->data << " ";\
        curr = curr->next;\
    \} while (curr != q->front);\
\
    cout << endl;\
\}\
\
int main() \{\
  \
    Queue *q = new Queue;\
\
    enQueue(q, 14);\
    enQueue(q, 22);\
    enQueue(q, 6);\
    enQueue(q, 20);\
\
    cout << "Front value: " << front(q) << endl;\
    cout << "Rear value: " << rear(q) << endl;\
\
    printQueue(q);\
\
    cout << "Deleted value = " << deQueue(q) << endl;\
    cout << "Deleted value = " << deQueue(q) << endl;\
\
    printQueue(q);\
\
    return 0;\
\}\
\
\
Solution:\
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 #include\cf4 \strokec4  \cf5 \strokec5 <bits/stdc++.h>\cf6 \cb1 \strokec6 \
\cf2 \cb3 \strokec2 using\cf6 \strokec6  \cf4 \strokec4 namespace\cf6 \strokec6  \cf7 \strokec7 std\cf6 \strokec6 ;\cb1 \
\
\cf4 \cb3 \strokec4 class\cf6 \strokec6  \cf7 \strokec7 Node\cf6 \strokec6  \{\cb1 \
\cf4 \cb3 \strokec4 public:\cf6 \cb1 \strokec6 \
\cb3     \cf4 \strokec4 int\cf6 \strokec6  data;\cb1 \
\cb3     Node* next;\cb1 \
\
\cb3     \cf8 \strokec8 Node\cf6 \strokec6 (\cf4 \strokec4 int\cf6 \strokec6  \cf9 \strokec9 value\cf6 \strokec6 ) \{\cb1 \
\cb3         data = value;\cb1 \
\cb3         next = \cf4 \strokec4 nullptr\cf6 \strokec6 ;\cb1 \
\cb3     \}\cb1 \
\cb3 \};\cb1 \
\
\cf4 \cb3 \strokec4 class\cf6 \strokec6  \cf7 \strokec7 MyCircularQueue\cf6 \strokec6  \{\cb1 \
\cf4 \cb3 \strokec4 private:\cf6 \cb1 \strokec6 \
\cb3     Node* front;\cb1 \
\cb3     Node* rear;\cb1 \
\cb3     \cf4 \strokec4 int\cf6 \strokec6  size;\cb1 \
\cb3     \cf4 \strokec4 int\cf6 \strokec6  capacity;\cb1 \
\
\cf4 \cb3 \strokec4 public:\cf6 \cb1 \strokec6 \
\cb3     \cf8 \strokec8 MyCircularQueue\cf6 \strokec6 (\cf4 \strokec4 int\cf6 \strokec6  \cf9 \strokec9 k\cf6 \strokec6 ) \{\cb1 \
\cb3         front = \cf4 \strokec4 nullptr\cf6 \strokec6 ;\cb1 \
\cb3         rear = \cf4 \strokec4 nullptr\cf6 \strokec6 ;\cb1 \
\cb3         size = \cf10 \strokec10 0\cf6 \strokec6 ;\cb1 \
\cb3         capacity = k;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf4 \strokec4 bool\cf6 \strokec6  \cf8 \strokec8 enQueue\cf6 \strokec6 (\cf4 \strokec4 int\cf6 \strokec6  \cf9 \strokec9 value\cf6 \strokec6 ) \{\cb1 \
\cb3         \cf2 \strokec2 if\cf6 \strokec6  (\cf8 \strokec8 isFull\cf6 \strokec6 ()) \cf2 \strokec2 return\cf6 \strokec6  \cf4 \strokec4 false\cf6 \strokec6 ;\cb1 \
\
\cb3         Node* newNode = \cf2 \strokec2 new\cf6 \strokec6  \cf8 \strokec8 Node\cf6 \strokec6 (value);\cb1 \
\cb3         \cf2 \strokec2 if\cf6 \strokec6  (\cf8 \strokec8 isEmpty\cf6 \strokec6 ()) \{\cb1 \
\cb3             front = newNode;\cb1 \
\cb3             rear = newNode;\cb1 \
\cb3             \cf9 \strokec9 rear\cf6 \strokec6 ->\cf9 \strokec9 next\cf6 \strokec6  = front;\cf11 \strokec11  // Point to itself in a circular manner\cf6 \cb1 \strokec6 \
\cb3         \} \cf2 \strokec2 else\cf6 \strokec6  \{\cb1 \
\cb3             \cf9 \strokec9 rear\cf6 \strokec6 ->\cf9 \strokec9 next\cf6 \strokec6  = newNode;\cb1 \
\cb3             rear = newNode;\cb1 \
\cb3             \cf9 \strokec9 rear\cf6 \strokec6 ->\cf9 \strokec9 next\cf6 \strokec6  = front;\cb1 \
\cb3         \}\cb1 \
\
\cb3         size++;\cb1 \
\cb3         \cf2 \strokec2 return\cf6 \strokec6  \cf4 \strokec4 true\cf6 \strokec6 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf4 \strokec4 bool\cf6 \strokec6  \cf8 \strokec8 deQueue\cf6 \strokec6 () \{\cb1 \
\cb3         \cf2 \strokec2 if\cf6 \strokec6  (\cf8 \strokec8 isEmpty\cf6 \strokec6 ()) \cf2 \strokec2 return\cf6 \strokec6  \cf4 \strokec4 false\cf6 \strokec6 ;\cb1 \
\
\cb3         \cf2 \strokec2 if\cf6 \strokec6  (front == rear) \{\cf11 \strokec11  // Only one element\cf6 \cb1 \strokec6 \
\cb3             \cf2 \strokec2 delete\cf6 \strokec6  front;\cb1 \
\cb3             front = \cf4 \strokec4 nullptr\cf6 \strokec6 ;\cb1 \
\cb3             rear = \cf4 \strokec4 nullptr\cf6 \strokec6 ;\cb1 \
\cb3         \} \cf2 \strokec2 else\cf6 \strokec6  \{\cb1 \
\cb3             Node* temp = front;\cb1 \
\cb3             front = \cf9 \strokec9 front\cf6 \strokec6 ->\cf9 \strokec9 next\cf6 \strokec6 ;\cb1 \
\cb3             \cf9 \strokec9 rear\cf6 \strokec6 ->\cf9 \strokec9 next\cf6 \strokec6  = front;\cb1 \
\cb3             \cf2 \strokec2 delete\cf6 \strokec6  temp;\cb1 \
\cb3         \}\cb1 \
\
\cb3         size--;\cb1 \
\cb3         \cf2 \strokec2 return\cf6 \strokec6  \cf4 \strokec4 true\cf6 \strokec6 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf4 \strokec4 int\cf6 \strokec6  \cf8 \strokec8 Front\cf6 \strokec6 () \{\cb1 \
\cb3         \cf2 \strokec2 if\cf6 \strokec6  (\cf8 \strokec8 isEmpty\cf6 \strokec6 ()) \cf2 \strokec2 return\cf6 \strokec6  -\cf10 \strokec10 1\cf6 \strokec6 ;\cb1 \
\cb3         \cf2 \strokec2 return\cf6 \strokec6  \cf9 \strokec9 front\cf6 \strokec6 ->\cf9 \strokec9 data\cf6 \strokec6 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf4 \strokec4 int\cf6 \strokec6  \cf8 \strokec8 Rear\cf6 \strokec6 () \{\cb1 \
\cb3         \cf2 \strokec2 if\cf6 \strokec6  (\cf8 \strokec8 isEmpty\cf6 \strokec6 ()) \cf2 \strokec2 return\cf6 \strokec6  -\cf10 \strokec10 1\cf6 \strokec6 ;\cb1 \
\cb3         \cf2 \strokec2 return\cf6 \strokec6  \cf9 \strokec9 rear\cf6 \strokec6 ->\cf9 \strokec9 data\cf6 \strokec6 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf4 \strokec4 bool\cf6 \strokec6  \cf8 \strokec8 isEmpty\cf6 \strokec6 () \{\cb1 \
\cb3         \cf2 \strokec2 return\cf6 \strokec6  size == \cf10 \strokec10 0\cf6 \strokec6 ;\cb1 \
\cb3     \}\cb1 \
\
\cb3     \cf4 \strokec4 bool\cf6 \strokec6  \cf8 \strokec8 isFull\cf6 \strokec6 () \{\cb1 \
\cb3         \cf2 \strokec2 return\cf6 \strokec6  size == capacity;\cb1 \
\cb3     \}\cb1 \
\cb3 \};\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf12 \outl0\strokewidth0 \
\
\pard\pardeftab720\sa240\partightenfactor0
\ls1\ilvl0
\f2\b\fs24 \cf0 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec13 Time Complexity
\f3\b0 :\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f4\fs26 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec13 enQueue
\f3\fs24  and 
\f4\fs26 deQueue
\f3\fs24 : 
\f5 O\uc0\u8232 (\u8232 1\u8232 )\u8232 \u8232 
\f3 O(1)
\f5 \uc0\u8232 
\f3 O(1), as insertion and deletion are performed at the ends.\
\ls1\ilvl0
\f4\fs26 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec13 Front
\f3\fs24  and 
\f4\fs26 Rear
\f3\fs24 : 
\f5 O\uc0\u8232 (\u8232 1\u8232 )\u8232 \u8232 
\f3 O(1)
\f5 \uc0\u8232 
\f3 O(1), as pointers to the front and rear are maintained.\
\pard\pardeftab720\sa240\partightenfactor0
\ls1\ilvl0
\f2\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec13 Space Complexity
\f3\b0 :\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f5 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec13 O\uc0\u8232 (\u8232 n\u8232 )\u8232 \u8232 
\f3 O(n)
\f5 \uc0\u8232 
\f3 O(n), where 
\f5 n\uc0\u8232 \u8232 
\f3 n
\f5 \uc0\u8232 
\f3 n is the current number of elements in the queue (dynamic allocation for each node).\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\
}